name: go-release-docker

on:
  workflow_dispatch:
  push:
    tags:
      - "*"

# 必须配置权限
permissions:
  contents: write
  packages: write

jobs:
  # 1. 编译 Go 二进制文件 (并行处理多系统打包)
  build-binaries:
    name: Build Binaries
    runs-on: ubuntu-latest
    outputs:
      VERSION: ${{ steps.get_version.outputs.VERSION }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set Version
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - uses: actions/setup-go@v5
        with:
          go-version: 'stable'

      - name: Install gox
        run: go install github.com/mitchellh/gox@latest

      # 假设你的 make gox-all 会把文件输出到 build/ 目录，并且按目录分好了架构
      # 比如: build/linux_amd64/your_app
      - name: Go Build Multi-platform
        run: make gox-all

      # 打包成 tar.gz
      - name: Package Artifacts
        run: |
          mkdir -p releases
          # 定义项目名称
          APP_NAME=$(basename ${GITHUB_REPOSITORY})
          
          # 遍历 build 下的文件夹进行压缩 (适配 gox 默认输出目录模式)
          for dir in ./build/*; do
            if [ -d "$dir" ]; then
              PLATFORM=$(basename "$dir") # 例如 linux_amd64
              BINARY_NAME=$(basename ${GITHUB_REPOSITORY})
              if [ -f "$dir/$BINARY_NAME" ]; then
                TEMP_DIR=$(mktemp -d)
                cp "$dir/$BINARY_NAME" "$TEMP_DIR/"
                if [ -d "./config" ]; then
                  cp -r ./config "$TEMP_DIR/"
                fi
                tar -czvf "releases/${APP_NAME}-${PLATFORM}.tar.gz" -C "$TEMP_DIR" .
                rm -rf "$TEMP_DIR"
              else
                echo "Binary file not found in $dir, skipping..."
              fi
            fi
          done

      # 创建 Release 并上传所有 tar.gz
      - name: Create Release and Upload Assets
        uses: softprops/action-gh-release@v2
        with:
          files: releases/*.tar.gz
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # 2. 构建并推送 Docker 镜像到 GitHub Container Registry
  build-push-docker:
    name: Build & Push Docker to GHCR
    runs-on: ubuntu-latest
    needs: build-binaries # 依赖二进制构建完成后运行
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 登录 GHCR
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 自动生成 metadata (tags, labels)
      # 这里的逻辑是：如果是 tag v1.0.0，它会自动生成 :v1.0.0 和 :latest (默认行为)
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest,enable=${{ !contains(github.ref, '-') }}

      # 构建并推送
      - name: Build and push Docker images
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ needs.build-binaries.outputs.VERSION }}
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            GIT_COMMIT=${{ github.sha }}
