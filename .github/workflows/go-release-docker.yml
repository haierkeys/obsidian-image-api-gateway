name: go-release-docker

on:
  workflow_dispatch:
  push:
    tags:
      - "*"

# 必须配置权限
permissions:
  contents: write
  packages: write

jobs:
  # 1. 编译 Go 二进制文件 (并行处理多系统打包)
  build-binaries:
    name: Build Binaries
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      VERSION: ${{ steps.get_version.outputs.VERSION }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set Version
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - uses: actions/setup-go@v5
        with:
          go-version: 'stable'

      - name: Install gox
        run: go install github.com/mitchellh/gox@latest

      # 假设你的 make gox-all 会把文件输出到 build/ 目录，并且按目录分好了架构
      # 比如: build/linux_amd64/your_app
      - name: Go Build Multi-platform
        run: make gox-all

      # 打包成 tar.gz
      - name: Package Artifacts
        run: |
          mkdir -p releases
          # 定义项目名称
          APP_NAME=$(basename ${GITHUB_REPOSITORY})
          
          # 这里假设 make gox-all 生成了如下结构 (根据你的原脚本推测)
          # 如果 gox 生成的是单文件名为 app_linux_amd64，你需要调整这里的打包逻辑
          
          # 遍历 build 下的文件夹进行压缩 (适配 gox 默认输出目录模式)
          for dir in ./build/*; do
            if [ -d "$dir" ]; then
              PLATFORM=$(basename "$dir") # 例如 linux_amd64
              # 压缩 config 目录和 二进制文件
              tar -czvf "releases/${APP_NAME}-${PLATFORM}.tar.gz" -C ./config . -C "$dir" .
            fi
          done

      # 创建 Release 并上传所有 tar.gz
      - name: Create Release and Upload Assets
        uses: softprops/action-gh-release@v2
        with:
          files: releases/*.tar.gz
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # 2. 构建并推送 Docker 镜像 (依赖 build-binaries 完成，或者并行运行)
  build-push-docker:
    name: Build & Push Docker
    runs-on: ubuntu-latest
    needs: build-binaries # 也可以设为不依赖，并行跑更快
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 登录 DockerHub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ github.actor }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 登录 GHCR
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 自动生成 metadata (tags, labels)
      # 这里的逻辑是：如果是 tag v1.0.0，它会自动生成 :v1.0.0 和 :latest (默认行为)
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ github.repository }}
            ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest,enable=${{ !contains(github.ref, '-') }}

      # 构建并推送
      - name: Build and push Docker images
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ needs.build-binaries.outputs.VERSION }}
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            GIT_COMMIT=${{ github.sha }}